import os 
import re
import json
import numpy as np
from preprocess_llm import build_zs_instances

def parse_useful_txt(filename):
    START_AND_END_SYMBOL = '--------------------'
    FLAG_END = 'FLAG_END'
    FLAG_START = 'FLAG_START'
    regexp = '--------------------\n((FLAG_START\n(.?)*\nFLAG_END)*\n*)*--------------------'
    with open(filename, 'r') as f:
        content = f.read()
    useful_txt = re.search(regexp, content)
    trimmed = useful_txt.group(0)
    #regexp2 = '(FLAG_START\n(.?)*\nFLAG_END)'
    regexp2 = 'No|no|Yes|yes|Contradiction|contradiction|entailment|Entailment'
    answers = re.findall(regexp2, trimmed)
    #parsed_answer = answer.group(0)
    #print(parsed_answer)
    return answers
    #regexp3 = ''
    #trimmed_answer = re.search(regexp3, answer)
    #print(useful_txt.index('-------'))


def parse_label(answers):
    """
        Function to parse the actual answer given by the LLM. 

        :answer: list of answers generated by the model

        return: "entailment"/"contradiction" (string) 
    """

    CONTRADICTION_TERMS = ['No', 'no', 'Contradiction.', 'there is no entailment', 'there is a contradiction', 'are contradictory', 'Negation of entailment']
    ENTAILMENT_TERMS = ['yes', 'Yes', 'there is an entailment', 'Entailment.', 'there is no contradiction', 'not contradictory', 'statement is supported', 'Not a contradiction', 'No contradiction', 'Non-Contradiction', 'does not conflict']


    preds = []
    #regexp = re.compile("No|no|Contradiction\.|there is no entailment|there is a contradiction|are contradictory|Negation of entailment|there is an entailment|Entailment\.|there is no contradiction|not contradictory|statement is supported|No contradiction|Non-Contradiction|does not conflict|yes|Yes")
    
    for i in answers:
        #label = re.findall(regexp, i)
        if len(i) > 0:
            if i in CONTRADICTION_TERMS:
                label = 'Contradiction'
            elif i in ENTAILMENT_TERMS:
                label = 'Entailment'
            preds.append(label)
        else:
            preds.append("None")
    return preds 


# NOTE change the file name each time !!
RESULTS_FILE = '/XXX/results_muffin_flan_t5.json'

def format_results(ctr_ids, preds):
    """
        Format the obtained predictions into the challenge's format and saves it in the file results.json.
    """
    content = {}

    for i in range(len(ctr_ids)):
        content[str(ctr_ids[i])] = {'Prediction': preds[i]}

    with open(RESULTS_FILE, 'w+') as f:
        f.write(json.dumps(content,indent=4))


"""
SUBMISSION FORMAT 
{

    "f17cb242-419d-4f5d-bfa4-41494ed5ac0e": {

        "Prediction": "Contradiction"

    }

}

"""

def main():

    # NOTE: change the file name each time, I was to lazy to put an argument parser 
    answers = parse_useful_txt('/XXXXX/example_stdout.txt')
    preds = parse_label(answers)

    all_templates, all_ids = build_zs_instances()

    format_results(all_ids, preds)


if __name__ == "__main__":
    main()
